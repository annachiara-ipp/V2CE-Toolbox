import numpy as np
from skimage.measure import block_reduce
from scipy.ndimage import gaussian_filter

from .v2e_utils import lin_log


def gen_mosaic_frame(frame, pool_size=8):
    """
    Generate a mosaic frame from a frame by averaging over patches of size pool_size
    Args:
        frame: input frame, shape (H, W)
        pool_size: size of the patches, int
    Returns:
        frame_patches: mosaic frame, shape (H/pool_size, W/pool_size)
    """
    # Define pooling size and stride
    stride = pool_size

    # Ensure the input is float type
    frame = frame.astype(np.float32)

    # Use block_reduce to downsample the input
    frame_patches = block_reduce(frame, block_size=(pool_size, stride), func=np.mean)
    return frame_patches
    
def gen_event_frame(events, frame_size):
    """
    Generate an event frame from an array of events
    Args:
        events: array of events, shape (N, 4)
        frame_size: size of the frame, tuple (H, W)
    Returns:
        event_count_frame: event frame, shape (H, W)
    """
    h, w = frame_size
    event_count_frame = np.zeros(
        (h, w), dtype="int"
    )

    for event in events:
        x = int(event[2])
        y = int(event[1])
        event_count_frame[x, y] += 1
    return event_count_frame

def gen_top_k_mask(input_array, K):
    """
    Generate a mask of the same shape as the input array, with True for the K largest values
    Args:
        input_array: input array, shape (H, W)
        K: number of values to select, int
    Returns:
        mask: mask of the same shape as the input array, shape (H, W)
    """
    # Flatten the array, find the K-th largest value
    threshold = np.partition(input_array.flatten(), -K)[-K]

    # Create a mask of the same shape, with True for values >= the K-th largest
    mask = input_array >= threshold
    # print(threshold, input_array.max(), mask.sum())
    return mask

def physical_mask_generation(events, frames, K, threshold=0.6, pool_size=8):
    """
    Generate a physical mask from an array of events and frames
    Args:
        events: array of events, shape (N, 4)
        frames: array of frames, shape (2, H, W)
        K: number of top values to select, int
        threshold: threshold for the delta_lg calculation, float
        pool_size: size of the patches, int
    Returns:
        ratio_map_mask: physical mask, shape (H/pool_size, W/pool_size)
    """
    frames = frames + 1e-6
    # Normal Threshold: 0.3, used in v2e code: 0.2, 3 is for compensation and matching real events number
    delta_lg = np.abs(lin_log(frames[1]) - lin_log(frames[0])) / threshold
    event_frame = gen_event_frame(events, frames.shape[1:3])
    event_frame_patches = gen_mosaic_frame(event_frame, pool_size=pool_size)
    delta_lg_patches = gen_mosaic_frame(delta_lg, pool_size=pool_size)
    ratio_map = event_frame_patches / (delta_lg_patches+1e-6) - 1
    ratio_map_mask = gen_top_k_mask(ratio_map, K)
    return ratio_map_mask, ratio_map

# def physical_attention_generation(events, frames, pool_size=8):
#     """
#     Generate a physical mask from an array of events and frames
#     Args:
#         events: list of array of events, shape (N, 4)
#         frames: array of frames, shape (2, H, W)
#         pool_size: size of the patches, int
#     Returns:
#         ratio_map: physical attention, shape (H/pool_size, W/pool_size)
#     """
#     frames = frames + 1e-6
#     # Normal Threshold: 0.3, used in v2e code: 0.2, 3 is for compensation and matching real events number
#     delta_lg = np.abs(lin_log(frames[1]) - lin_log(frames[0])) #!/ threshold
#     event_frame = gen_event_frame(events, frames.shape[1:3])
#     event_frame_patches = gen_mosaic_frame(event_frame, pool_size=pool_size)
#     delta_lg_patches = gen_mosaic_frame(delta_lg, pool_size=pool_size)
#     ratio_map = (event_frame_patches+1) / (delta_lg_patches+1)
#     # normalize ratio_map to [0, 1]
#     ratio_map = (ratio_map - ratio_map.min()) / (ratio_map.max() - ratio_map.min())
#     return ratio_map

def physical_attention_generation(events, frames, pool_size=8, ceiling=10):
    """
    Generate a physical mask from an array of events and frames
    Args:
        events: list of array of events, shape (N, 4)
        frames: array of frames, shape (2, H, W)
        pool_size: size of the patches, int
    Returns:
        ratio_map: physical attention, shape (H/pool_size, W/pool_size)
    """
    # calculate event frame patches 
    event_frame = gen_event_frame(events, frames.shape[1:3])
    event_frame_patches = gen_mosaic_frame(event_frame, pool_size=pool_size)
    # if a value in event_frame_patches is smaller than 3, set it to 0
    event_frame_patches[event_frame_patches < 0.05] = 0

    # calculate the event map generated by the residual of log frames
    frames = frames + 1e-6
    delta_lg = np.abs(lin_log(frames[1]) - lin_log(frames[0])) #!/ threshold
    delta_lg_patches = gen_mosaic_frame(delta_lg, pool_size=pool_size)

    # calculate ratio_map
    # ratio_map = (event_frame_patches+1) / (delta_lg_patches+1)
    ratio_map = event_frame_patches / (delta_lg_patches+1e-3)
    
    ratio_map = np.clip(ratio_map, 0, ceiling*2)

    # apply gaussian blur to ratio_map
    ratio_map = gaussian_filter(ratio_map, sigma=1)

    # clamp the ratio_map to [1, ceiling]
    ratio_map = np.clip(ratio_map, 0, ceiling)
    
    # normalize ratio_map to [0, 1], be careful with the denominator
    if ratio_map.max() != ratio_map.min():
        ratio_map = ratio_map / ceiling
    else:
        ratio_map = np.zeros_like(ratio_map)
    
    return ratio_map



def physical_attention_generation_advanced(events, frames, pool_size=8, ceiling=5):
    """
    Generate a physical mask from an array of events and frames
    Args:
        events: list of array of events, shape (N, 4)
        frames: array of frames, shape (2, H, W)
        pool_size: size of the patches, int
    Returns:
        ratio_map: physical attention, shape (H/pool_size, W/pool_size)
    """
    # calculate event frame patches 
    event_frame = gen_event_frame(events, frames.shape[1:3])
    event_frame_patches = gen_mosaic_frame(event_frame, pool_size=pool_size)
    # if a value in event_frame_patches is smaller than 3, set it to 0
    event_frame_patches[event_frame_patches < 0.05] = 0

    # calculate the event map generated by the residual of log frames
    frames = frames + 1e-6
    delta_lg = np.abs(lin_log(frames[1]) - lin_log(frames[0])) #!/ threshold
    delta_lg_patches = gen_mosaic_frame(delta_lg, pool_size=pool_size)

    # calculate ratio_map
    # ratio_map = (event_frame_patches+1) / (delta_lg_patches+1)
    ratio_map = event_frame_patches / (delta_lg_patches+1e-3)
    
    ratio_map = np.clip(ratio_map, 0, ceiling*2)

    # apply gaussian blur to ratio_map
    ratio_map = gaussian_filter(ratio_map, sigma=1)

    # clamp the ratio_map to [1, ceiling]
    ratio_map = np.clip(ratio_map, 0, ceiling)
    
    # normalize ratio_map to [0, 1], be careful with the denominator
    if ratio_map.max() != ratio_map.min():
        ratio_map = (ratio_map - ratio_map.min()) / (ratio_map.max() - ratio_map.min())
    else:
        ratio_map = np.zeros_like(ratio_map)
    

    # not [0,1], but [-0.25, 1]
    # ratio_map = (ratio_map-1)/(ceiling-1)
    
    return ratio_map


def physical_attention_batch_generation(events, frames, pool_size=8, advanced=False, ceiling=5):
    """
    Generate a physical mask from an array of events and frames in batch
    Args:
        events: list of array of events, shape [B, (N, 4)]
        frames: array of frames, shape (B, 2, H, W)
        pool_size: size of the patches, int
    Returns:
        ratio_maps: physical attention, shape (B, H/pool_size, W/pool_size)
    """
    ratio_maps = []
    for i in range(frames.shape[0]):
        if advanced:
            ratio_maps.append(physical_attention_generation_advanced(events[i], frames[i], pool_size, ceiling=ceiling))        
        else:
            ratio_maps.append(physical_attention_generation(events[i], frames[i], pool_size))
    ratio_maps = np.stack(ratio_maps, axis=0)
    return ratio_maps


def gen_log_frame_residual(frames):
    """
    Generate a residual frame from a pair of log frames
    Args:
        frames: array of frames, shape (2, H, W)
    Returns:
        residual_frame: residual frame, shape (1, H, W), where we separate the positive and negative values as two channels
    """
    # N, H, W = frames.shape
    # residual_frames = np.zeros((N-1, 1, H, W))
    residual_frame = lin_log(frames[1]) - lin_log(frames[0])
    residual_frame = residual_frame[np.newaxis, ...]
    # residual_frame[0] = residual * (residual > 0)
    # residual_frame[1] = residual * (residual < 0)
    return residual_frame

def gen_log_frame_residual_batch(frames):
    """
    Generate a residual frame from a batch of log frames
    Args:
        frames: array of frames, shape (N, H, W)
    Returns:
        residual_frame: residual frame, shape (N-1, 1, H, W), where we separate the positive and negative values as two channels
    """
    # N, H, W = frames.shape
    # residual_frames = np.zeros((N-1, 2, H, W))
    lin_log_frames = lin_log(frames)
    residual_frames = lin_log_frames[1:] - lin_log_frames[:-1]
    residual_frames = residual_frames[:, np.newaxis, ...]
    # residual_frames[:, 0] = residual * (residual > 0)
    # residual_frames[:, 1] = residual * (residual < 0)
    return residual_frames